#include<iostream>
#include<opencv2/opencv.hpp>

using namespace std;
using namespace cv;

int main(){

	Mat Img = imread("1.jpeg");
	
	unsigned char PixelB, PixelG, PixelR;  
	unsigned char Dif = 60;            
	unsigned char B = 180, G = 63, R = 23; 

	Mat RGBImg = Img.clone(); 
	int i = 0, j = 0;
	for (i = 0; i < Img.rows; i++)  
	{
		for (j = 0; j < Img.cols; j++)
		{
			PixelB = Img.at<Vec3b>(i, j)[0]; 
			PixelG = Img.at<Vec3b>(i, j)[1];
			PixelR = Img.at<Vec3b>(i, j)[2];

			if (abs(PixelB - B) < Dif && abs(PixelG - G) < Dif && abs(PixelR - R) < Dif)
			{                                          
				RGBImg.at<Vec3b>(i, j)[0] = 255; 
				RGBImg.at<Vec3b>(i, j)[1] = 255;
				RGBImg.at<Vec3b>(i, j)[2] = 255;
			}
			else
			{
				RGBImg.at<Vec3b>(i, j)[0] = 0; 
				RGBImg.at<Vec3b>(i, j)[1] = 0;
				RGBImg.at<Vec3b>(i, j)[2] = 0;
			}
		}
	}

	Mat OriImg; 
	Mat element = getStructuringElement(MORPH_RECT, Size(3, 3)); 
	dilate(RGBImg, OriImg, element); 
	dilate(OriImg, OriImg, element);
	dilate(OriImg, OriImg, element);
	dilate(OriImg, OriImg, element);
	dilate(OriImg, OriImg, element);

	erode(OriImg, OriImg, element);
	erode(OriImg, OriImg, element);     
	erode(OriImg, OriImg, element);
	erode(OriImg, OriImg, element);
	erode(OriImg, OriImg, element);

	Mat edge;
	Canny(OriImg, edge, 100, 250, 3, false);

	dilate(edge, OriImg, element);
	erode(OriImg, edge, element);
	
	vector<vector<Point>>contours;
	findContours(edge,contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

	vector<vector<Point>>new_contours;
	for (int i = 0; i < contours.size(); i++) {

		double area = contourArea(contours[i]);
		if (area < 1800) {
			continue;
		}

		RotatedRect box = minAreaRect(contours[i]);
		vector<Point2f>box_points(4);

		box.points(box_points.data());
		for (int j = 0;j < 4;j++) {
			line(Img, box_points[j], box_points[(j + 1) % 4], Scalar(0, 0, 255), 4);
		}

		new_contours.emplace_back(contours[i]);
	}

	namedWindow("Img", 0);
	resizeWindow("Img", Img.size() / 6);
	imshow("Img", Img);

	waitKey(0);
	return 0;
}
