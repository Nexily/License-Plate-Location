# 车牌定位

## 使用条件

根据车牌颜色调整二值化阈值来识别车牌

## 使用原理

### 1.针对车牌颜色进行二值化

```c++
unsigned char PixelB, PixelG, PixelR;  //记录三通道值
unsigned char Dif = 60; //用于颜色区分的误差设置
unsigned char B = 180, G = 63, R = 23; //针对蓝色车牌的三通道阈值设定

Mat RGBImg = Img.clone(); 
int i = 0, j = 0;
for (i = 0; i < Img.rows; i++)  
{
	for (j = 0; j < Img.cols; j++)
	{
		PixelB = Img.at<Vec3b>(i, j)[0]; //获取图片三通道值
		PixelG = Img.at<Vec3b>(i, j)[1];
		PixelR = Img.at<Vec3b>(i, j)[2];

        //将三通道的值和三通道的阈值进行比较
		if (abs(PixelB - B) < Dif && abs(PixelG - G) < Dif && abs(PixelR - R) < Dif) 
		{   
            //符合颜色阈值范围内的设置成白色
			RGBImg.at<Vec3b>(i, j)[0] = 255; 
			RGBImg.at<Vec3b>(i, j)[1] = 255;
			RGBImg.at<Vec3b>(i, j)[2] = 255;
		}
		else
		{
             //不符合颜色阈值范围内的设置为黑色
			RGBImg.at<Vec3b>(i, j)[0] = 0;
			RGBImg.at<Vec3b>(i, j)[1] = 0;
			RGBImg.at<Vec3b>(i, j)[2] = 0;
		}
	}
}
```

### 2.形态学处理结果图像

```c++
Mat OriImg; 
Mat element = getStructuringElement(MORPH_RECT, Size(3, 3)); //设置形态学处理窗大小

dilate(RGBImg, OriImg, element); //进行多次膨胀
dilate(OriImg, OriImg, element);
dilate(OriImg, OriImg, element);
dilate(OriImg, OriImg, element);
dilate(OriImg, OriImg, element);

erode(OriImg, OriImg, element);  //进行多次腐蚀
erode(OriImg, OriImg, element);     
erode(OriImg, OriImg, element);
erode(OriImg, OriImg, element);
erode(OriImg, OriImg, element);
```

### 3.边缘识别

```c++
Mat edge;
Canny(OriImg, edge, 100, 250, 3, false);
```

### 4.再次进行形态学处理使边缘图像闭合

```C++
dilate(edge, OriImg, element); //膨胀
erode(OriImg, edge, element); //腐蚀
```

### 5.寻找轮廓

```c++
vector<vector<Point>>contours;
findContours(edge,contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE); //寻找外轮廓
```

### 6.画出面积筛选后轮廓的外接矩形

```c++
vector<vector<Point>>new_contours;
for (int i = 0; i < contours.size(); i++) {  //遍历
    double area = contourArea(contours[i]);  //计算轮廓面积
	if (area < 1800) {   //如果面积过小，跳过
		continue;
	}

	RotatedRect box = minAreaRect(contours[i]); //旋转矩形，得到最小外接矩形
	vector<Point2f>box_points(4);

	box.points(box_points.data()); //提取矩形四个顶点
	for (int j = 0;j < 4;j++) {
		line(Img, box_points[j], box_points[(j + 1) % 4], Scalar(0, 0, 255), 4); //画直线
	}
    new_contours.emplace_back(contours[i]);
}
```

## 完整代码

```c++
#include<iostream>
#include<opencv2/opencv.hpp>

using namespace std;
using namespace cv;

int main(){

    //读取图片
	Mat Img = imread("1.jpeg"); 
	
    //针对车牌颜色进行二值化
	unsigned char PixelB, PixelG, PixelR;  //记录三通道值
	unsigned char Dif = 60;  //用于颜色区分的误差设置           
	unsigned char B = 180, G = 63, R = 23; //针对蓝色车牌的三通道阈值设定

	Mat RGBImg = Img.clone(); 
	int i = 0, j = 0;
	for (i = 0; i < Img.rows; i++)  
	{
		for (j = 0; j < Img.cols; j++)
		{
			PixelB = Img.at<Vec3b>(i, j)[0]; //获取图片三通道值
			PixelG = Img.at<Vec3b>(i, j)[1];
			PixelR = Img.at<Vec3b>(i, j)[2];

            //将三通道的值和三通道的阈值进行比较
			if (abs(PixelB - B) < Dif && abs(PixelG - G) < Dif && abs(PixelR - R) < Dif)
			{                                          
				RGBImg.at<Vec3b>(i, j)[0] = 255; 
				RGBImg.at<Vec3b>(i, j)[1] = 255;
				RGBImg.at<Vec3b>(i, j)[2] = 255;
			}
			else
			{
                //不符合颜色阈值范围内的设置为黑色
				RGBImg.at<Vec3b>(i, j)[0] = 0; 
				RGBImg.at<Vec3b>(i, j)[1] = 0;
				RGBImg.at<Vec3b>(i, j)[2] = 0;
			}
		}
	}

    //形态学处理结果图像
	Mat OriImg; 
	Mat element = getStructuringElement(MORPH_RECT, Size(3, 3)); //设置形态学处理窗大小
    
	dilate(RGBImg, OriImg, element); //进行多次膨胀
	dilate(OriImg, OriImg, element);
	dilate(OriImg, OriImg, element);
	dilate(OriImg, OriImg, element);
	dilate(OriImg, OriImg, element);

	erode(OriImg, OriImg, element); //进行多次腐蚀
	erode(OriImg, OriImg, element);     
	erode(OriImg, OriImg, element);
	erode(OriImg, OriImg, element);
	erode(OriImg, OriImg, element);

    //边缘识别
	Mat edge;
	Canny(OriImg, edge, 100, 250, 3, false);

    //形态学处理结果图像
	dilate(edge, OriImg, element); //膨胀
	erode(OriImg, edge, element); //腐蚀
	
	vector<vector<Point>>contours;
	findContours(edge,contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    //画出面积筛选后轮廓的外接矩形
	vector<vector<Point>>new_contours;
	for (int i = 0; i < contours.size(); i++) {  //遍历
		double area = contourArea(contours[i]);  //计算轮廓面积
		if (area < 1800) {    //如果面积过小，跳过
			continue;
		}

		RotatedRect box = minAreaRect(contours[i]);  //旋转矩形，得到最小外接矩形
		vector<Point2f>box_points(4);

		box.points(box_points.data());   //提取矩形四个顶点
		for (int j = 0;j < 4;j++) {
            //画直线
			line(Img, box_points[j], box_points[(j + 1) % 4], Scalar(0, 0, 255), 4);
		}
		new_contours.emplace_back(contours[i]);
	}

	namedWindow("Img", 0);
	resizeWindow("Img", Img.size() / 6);  //设定窗口大小
	imshow("Img", Img);  //展示图片

	waitKey(0);
	return 0;
}
```



